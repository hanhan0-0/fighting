# **第五章 散列**

## 5.1一般想法

- 理想的散列表数据结构只不过是一个含有关键字的具有固定大小的数组。典型情况下一个关键字就是一个带有相关值（例如工资信息）的字符串。
- 表的大小记作TableSize并将其理解为散列表数据结构的一部分而不仅仅是浮动了全局的某个变量。

## 5.2散列函数

- 关键字若是整数：key mod TableSize（好的办法是保证表的大小是素数）
- 通常关键字是字符串，一种选择是把字符中字符ASCLL码加起来
- 一个好的散列函数：

```c
Index Hash(const char*key,int TableSize)
{
    unsigned int HashVal=0;
    while(*key!='0')
        HashVal=(HashVal<<5)+*key++;//向左移五位相当于*32
    return HashVal%TableSize;
}
```

## 5.3分离链接法

把hash算完后的同一个值的所有元素保留在一个表中，Insert时插入重复元通常要留出一个额外的域，这个域当重复元出现时增加一。

```c
H->TheList=malloc(sizeof(list)*H->TableSize);//散列构造
H->TheList=malloc(sizeof(struct Listnode)*H->TableSize);//重复元的表构造
```

我们定义散列表的装填因子λ为散列表中的元素个数与散列表大小的比值，尽量使 λ=1；

## 5.4开放定址法

hi(x)=(Hash(x)+F(i)) mod TableSize;且 F(0)=0.

装填因子应该低于0.5。

### 5.4.1线性探测法

F是i的线性函数，典型是F(i)=i;如果超过一半的表被填满的话，那么线性探测就不是一个好办法。

### 5.4.2平方探测法

- F(i)=i*i;
- 如果表是一半空的，且表的大小是素数，那么我们总能够插入一个新的元素对平方探测，一旦表被填满超过一半了，当表的大小不是素数时甚至在表被填满一般之前就不能一次找到它单元了。这是因为嘴都有一半的表可以用作解决冲突的备选位置。
- 在找下一个探测单元时，可以用F(i)=F(i-1)+2i-1；来确定。

### 5.4.3双散列

F(i)=i*hash(x);

## 5.5再散列

- 建立另外一个大约大两倍的表（而且使用一个相关的新散列函数），扫描整个原始散列表，计算每个（非删除的）元素的新散列值并插入新表中。
- 如果超过某个装填因子就把散列扩大二倍再重新把数据填入。

## 5.6可扩散列

- 它允许用两次磁盘访问执行一次Find。
- 例：树的根含有四个指针，他们有这些数据的前两位确定。每片树叶中树的前两位都是相同的。用D代表根所使用的位数，有时称其为目录。于是，目录中的项数为2的n次方。所有未被分裂的树叶现在各由两个相邻目录所指。



# 第六章优先队列（堆）

对一些进程比较短的，应该尽快的结束，或者比较重要的应该具有优先权，为解决这样的特殊应用，需要优先队列来解决。

## 6.1模型

优先队列是允许至少两种操作的数据结构：Insert和DeleteMin，Insert等价于之前的入队，DeleteMin是找出返回和删除优先队列中的最小元素。

## 6.2一些简单的实现

- 使用一个链表插入，遍历最小值删除，基于DeleteMin使用次数不多于删除操作次数，因此这个办法更好一些。
- 二叉查找树

## 6.3二叉堆

同二叉查找树一样，堆也有两个性质，即结构性和堆序性。堆的操作必须要到堆的所有性质都被满足时才能终止。

### 6.3.1结构性质

- 堆是一棵完全被填满的二叉树，有可能的例外是在底层，底层上的元素从左到右填入，这样的树称为完全二叉树。

- 因为完全二叉树很有规律，所以它可以用一个数组表示而不需要指针：对于数组中任意位置i，其左儿子在位置2i，右儿子在2i+1，它的父亲则在[i/2]上。唯一问题在于堆大小要事先估计。

- 因此一个堆数据结构将由一个数组，一个代表最大值的整数以及当前的堆大小组成。

### 6.3.2堆序性质

由于我们想要快速的找出最小元，因此最小元应该在根上。任意节点应该小于他的所有后裔。

### 6.3.3基本的堆操作









