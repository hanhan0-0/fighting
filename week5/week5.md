# 第七章 排序

- 不能在主存中完成而必须在磁带中完成的排序叫做外部排序。
- 任何通用的排序算法都需要Ω(NlogN)次比较。

## 7.1预备知识

1. 每个算法都将接受一个含有元素的数组和一个包含元素个数的整数。
2. 假设N是传递到排序例程中的元素个数，它已经被检查过，是合法的。按照C都约定，对于所有的排序，数据都将在位置0处开始。
3. 假设‘<’和‘>’存在，除赋值语句外，这两种运算是仅有的允许对输入数据进行的操作。

在这三种条件下的排序叫做基于比较的排序。

## 7.2插入排序

### 7.2.1算法

插入排序由N-1趟排序组成。对于P=1趟到P=N-1趟，插入排序保证从位置0到位置P-1上的元素都是已排过序的。

```c
void insert(int A[],int N)
{
    int j,P,num;
    for(P=1;P<N;P++)
    {
        num=A[P];
        for(j=P;j>0&&A[j-1]>num;--j)
        {
            A[j]=[j-1];
        }
        A[j]=num;
    }
}
```

插入排序的平均情形是θ(N²)

## 7.3一些简单排序算法的下界

- 逆序是指数组中具有i<j但A[i]>A[j]的序偶(A[i],A[j])。
- 假设不存在重复元素、设输入数据是前N个整数的某个排列，并设所有的排列的都是等可能的。在这些条件下我们有如下定理：

#####       定理7.1 N个互异数的数组的平均逆序数是N(N-1)/4。

#####       定理7.2 通过交换相邻元素进行排序的任何算法平均需要Ω(N²)时间。

## 7.4 希尔排序

- 它通过比较相距一定间隔的元素来工作，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。
- 希尔排序使用一个序列h1,h2,h3....ht，叫做增量序列。只要h1=1任何增量序列都是可行的。
- 希尔排序一个重要的性质是一个hk-排序的文件，保持它hk-排序性。
- 希尔增量为ht=[N/2],hk=[hk+1/2].

##### 定理7.3使用希尔增量排序的最欢运行时间为θ(N²)。

- 希尔增量的问题在于这些增量未必互素，若增量不是素数，则要重复排序。
- Hibbard增量序列形如1，3，7...2的n次方-1，关键的区别是相邻增量没有公因子。

##### 定理7.4使用Hibbard增量的希尔排序的最坏情形运行时间为θ(N3/2)。

- Sedgewick提出了几种增量序列最坏运行时间是O(N4/3)实践中比Hibbard好，其中最好的序列为{1，5，19，41，109...}
- 编程简单的特点使得它成为较大的输入数据经常选用的算法。

## 7.5堆排序

- 堆排序给出至今见到的最佳的大O运行时间，但是实践中他却慢于使用Sedgewick增量序列的希尔排序。
- 第一步以线性时间建立一个堆。人后通过将堆中的最后元素与第一个元素交换，缩减堆的大小并进行下滤，来执行N-1次DeleteMax操作。当算法终止时就按照从小到大的顺序来排了。

##### 定理7.5对N个互异项的随机排列进行堆排序，所用的平均比较次数为2NlogN-O(NloglogN)。

## 7.6归并排序

- 归并排序以O(NlogN)最坏情形运行时间运行，而所使用的比较次数几乎是最优的。
- 归并排序，基本的合并算法是取两个数组A和B，一个输出数组C,以及三个计数器Aptr,Bptr,Cptr,他们初始置于对应数组的开始端。A[Aptr]和B[Bptr]中较小者被拷贝到C的下一个位置，相关计数器向前推进一步。递归地将前半部分数据和后半部分数据各自归并排序，得到排序后的两部分数据，然后使用上面描述的合并算法再将这两部分合并到一起。

## 7.7快速排序

- 快速排序是已知中最快的排序算法。

将数组排序的基本算法由下列简单四步构成：

1. 如果S中元素的格数是0或1，则返回。
2. 取S中任意元素v，称之为枢纽元。
3. 将S-{v}分成两个不相交的集合：S1={x∈S-{v}|x≤v}和S2={x∈S-{v}|x≥v}。
4. 返回{quicksort(S1)后，继而v，继而quicksort(S2)}。

### 7.7.1选取枢纽元

安全做法：随机选取枢纽元：三数中值分割法：使用左端、右端和中心位置上的三个元素的中值作为枢纽元。

### 7.7.2分割策略

当i在j的左边时，我们将i右移，移过那些小于枢纽元的元素，并将j左移，移过那些大于枢纽元的元素。当i和j停止时，i指向一个大元素而j指向一个小元素。如果i在j左边，那么将两个元素互换，其效果是把一个大元素移向右边而把一个小元素移向左边。

如果i和j遇到等于枢纽元的关键字，那么我们就让i和j都停止。

### 7.7.3小数组

对于很小的数组(N≤20)，快速排序不如插入排序好。

### 7.7.4实际的快速排序例程

选取枢纽元最容易的方法是对A[Left],A[Right],A[Center]适当的排序。我们可以把枢纽元放到A[Right-1]并在分割阶段将i和j初始化到Left+1和Right-2处。

### 7.7.5快速排序的分析

最坏情况: O(N²)

最好情况: O(NlogN)

平均情况: O(NlogN)

### 7.7.5选择的线性期望时间算法

前面步骤与快速排序一致，第四步如果K≤|S1|,那么第k个最小元必然在S1中。在这种情况下返回quicksection(S1,k).如果k=1+|S1|，那么枢纽元就是第k个最小元，我们将它作为答案返回。否咋这第k个最小元就在S2中，它是S2中的第（k-|S1|-1）个最小元，我们进行一次递归调用并返回quicksection(S2,k-|S1|-1)。当算法终止时第k个最小元就在位置k上。

## 7.8大型结构的排序

让输入数组包含指向结构的指针，我们通过比较指针指向的关键字，并在必要时交换指针来排序。这意味着，所有的数据运动基本上就像我们对整数排序那样进行。我们称之为间接排序。

## 7.9排序的一般下界

##### 决策树：

决策树是用于证明下界的抽象概念。决策树是一颗二叉树，每个节点表示在元素之间一组可能的排序，它与已经进行的比较一致，比较的结果是树的边。

只是用比较进行排序的每一种算法都可以用决策树表示。当然，只有输入数据非常少的情况下画决策树才是可行的。

## 7.10桶式排序

输入数据A1,A2,A3....An必须只有小于M的正整数组成。这种情况下，使用一个大小为M成为count的数组，它被初始化为全0.于是，count有M个单元（或称桶），这些桶初始化为空。当读Ai时count[Ai]增1。

输入只是一些小的整数的情况下用桶式排序。

## 7.11外部排序

他们是设计用来处理很大的输入的。

### 7.11.1为什么用新的算法

因为磁带上的元素只能被顺序访问

### 7.11.3简单算法

把每组排过序的叫做一个顺串。

第一步从输入磁带一次读入M个记录，在内部将这些记录排序，然后再把这些排过序的顺串交替写道Tb1或Tb2上。我们将每个磁盘的第一个顺串取出将二者合并，把结果写到Ta1上。再取顺串合并写到Ta2上。交替使用Ta1和Ta2。若还剩下一个顺串则拷贝它到适当的顺串上。再从Ta1,Ta2到Tb1,Tb2上，重复最终得到结果。

### 7.11.4多路合并

使用优先队列找出这些元素的最小元，为了得出下一个写到磁盘上的元素，我们进行一次DeleteMin操作，将相应的磁盘向前推进，弱国输入磁盘上的顺串尚未完成，那么我们将新元素插入优先队列中。

### 7.11.5多相合并

![image](https://user-images.githubusercontent.com/92200209/139532018-f5265dc0-1992-40c5-aff9-77bb23b85d2d.png)

### 7.11.6替换选择

![QQ图片20211028235519](https://user-images.githubusercontent.com/92200209/139531998-e9abf25f-bdc6-4bee-bddc-6adc2f4b6c4c.png)
