# 第八章不相交集ADT

## 8.1等价关系

等价关系满足三个性质的关系R：

1.（自反性）对于所有的a∈S，aRa。

2.（对称性）aRb当且仅当bRa。

3.（传递性）若aRb且bRc，则aRc。

## 8.2动态等价问题

- 等价类形成对S的一个划分：S的每个成员恰好出现在一个等价类中。为确定是否a～b，我们只需验证a和b是否都在同一个等价类中。
- 第一种运算是Find,它返回包含给定元素的集合（即等价类）的名字。第二种运算是添加关系。如果a和不在一个等价类中使用求并运算Union，合并成一个新的等价类去掉两个集合而保持所有的集合的不相交性，把这项工作的算法叫做不相交集合的Union/Find算法。
- 该算法是动态的；这个算法还必然是联机操作：当Find执行时，它必须给出答案算法才能继续进行。另一种可能是脱机算法：该算法需要观察全部的Union和Find序列。
- 真正重要的关键在于：Find(a)=Find(b)当且仅当a和b在同一个集合中。
- 解决动态等价问题的方案有两种：一种方案保证Find能够以常数最坏情形运行时间执行；而另一种方案保证指令Union能够以常数最坏情形运行时间执行。

## 8.3基本数据结构

我们可以假设树被非显示的存储在一个数组中，数组的每个成员P[i]表示元素i的父亲。如果i是根那么P[i]=0。

```c
void SetUnion(DisjSet S,SetType Root1,SetType Root2)//合并
{
    S[Root2]=Root1;
}
SetType Find(ElementType X,DisjSet S)//找根
{
    if(S[x]<=0)
       return X;
    else
        return Find(S[X],S);
}
```

## 8.4灵巧求并运算

- 按大小求并：为了实现这种算法我们需要记住每一棵树的大小，使用一个数组，让每个根的数组元素包含它的树的大小的负值，并且初始化数组时根为-1；当执行一次Union时要检查树的大小，新的大小是老的大小的和，
- 按高度求并：使用一个数组，让每个根的数组元素包含它的树的高度的负值，并且初始化数组时根为-1；当执行一次Union时要检查树的高度，高度不一样时，高度低的指向高度高的，一样时，其中一个根减一让另一个指向更高的上。

```c
void SetUnion(DisjSet S,SetType Root1,SetType Root2)//按高度求并
{
    if(S[Root2]<S[Root1])
        S[Root1]=Root2;
    else
    {
        if(S[Root1]==S[Root2])
            S[Root1]--;
        S[Root2]=Root1;
    }
}
```

## 8.5路径压缩

路径压缩在一次Find操作期间，而与用来执行的Union的方法无关。设操作Find(X)，此时路径压缩的效果是，从X到根的路径上的每一个节点都使它的父节点变成根。

```c
SetType Find(ElementType X,DisjSet S)//路径压缩
{
    if(S[x]<=0)
       return X;
    else
        return S[X]=Find(S[X],S);
}
```

路径压缩与按大小求并完全兼容；不完全与按高度求并兼容。

## 8.6按秩求并和路径压缩的最坏情形

- ##### 引理 8.1 当执行一系列Union指令时，一个秩（树的高度）为r的节点必然至少有2的r次方个后裔(包含它自己)

- ##### 引理 8.2 秩为r的节点的个数最多是N/2^r.

- ##### 引理 8.3 在Union/Find算法的任意时刻，从树叶到根的路径上的节点的秩单调增加。

- 当存在许多秩为0和1的节点时，随着r的增大秩为r的节点变少。

## 8.7 一个应用

很像路由表的交换信息不断地Union，测试一个路由表中是否有另一个路由表中的信息，没有就合并到一起去。

# 第十章 算法设计技巧

## 10.1 贪婪算法

- 贪婪算法分阶段的巩固走，在每一个阶段可以认为所作决定是最好的，而不考虑后来的结果。

- 当算法终止时，我们希望局部最优就是全局最优。如果是这样的话，那么算法就是正确的；否则算法得到的就是一个次优解。


### 10.1.1 一个简单的调度问题

- 非预占调度：一旦开始一个作业，就必须把该作业运行完。
- 操作系统调度程序一般把优先权赋予那些更短的作业，因为开销最小。
- 多处理器情况是按顺序开始作业，处理器之间轮换分配作业。

### 10.1.2 Huffman编码

- 每个字符通过根节点开始用0指示左分支用1指示右分支以记录路径的方式来表示出。字符代码的值为分率*深度。所以为了使总价值最小让频率低的深度最深频率高的字符深度最低。
- 没有字符代码是别的字符代码的前缀，这样的一种编码叫前缀编码。相反如果一个字符放在非树叶节点上那么就不能够保证译码没有二义性。

##### Huffman算法

任意选取两个权值最小的树T1,T2，形成以他俩为子树的新树，重复至只剩下最后的一棵满树。（满树：所有的节点，或者是树叶或者是有两个儿子）

该算法是两趟扫描算法。第一遍搜集频率数据，第二遍进行编码。对于大文件程序这个性质不是我们所希望的。

### 10.1.3 近似装箱问题

##### 联机算法

##### 定理10.1 存在使得任意联机装箱算法至少使用4/3最优箱子的输入。

###### 下项适合算法

- 当处理任何一件物品的时候，检查它是否还能装进刚刚装进物品的同一个箱子中，可以则装；不可以就开辟一个新的箱子。

##### 定理10.2 令M是将一列物品I装箱所需的最优装箱数，则下项适合算法所用箱数觉不超过2M个箱子。存在一些顺序使得下项适合算法用箱2M-2个。

###### 首次适合算法

- 依次扫描这些箱子但把新的一件物品放入以盛下他的第一个箱子中。因此只有当先前放置物品的箱子已经没有再容下当前物品余地的时候，我们才开辟一个新的箱子。

##### 定理10.3 令M是将一列物品I装箱所需的最优装箱数，则首次适合算法使用的箱子数绝对不多于[17/10M]。存在使得首次适合算法使用17/10(M-1)个箱子的顺序。

###### 最佳适合算法

- 把新的一件物品放到能容它最满的箱子中。

##### 脱机算法

将各项排序，把最大的物品放在最先，此时可以应用首次适合运算或者最佳适合算法，分别得到首次适合递减算法和最佳适合递减算法。

##### 如果一种最优装箱算法使用M个箱子，那么首次适合递减算法使用的箱子数绝对不会超过(4M+1)/3个。

## 10.2 分治算法

由两部分组成：

- 分：递归解决较小的问题
- 治：然后从子问题的解构建原问题的解。

我们一般坚持子问题是不相交的。

### 10.2.1 分治算法的运行时间

### 10.2.2 最近点问题

把点集分成两半：Pl和Pr。最近的一对点或者都在Pl或者都在Pr，或者一个在Pl另一个在Pr。把这三种距离叫d1,d2,d3；我们可以递归的计算的d1,d2，这个问题此时就是在计算d3。令σ=min(d1,d2),我们要求min(d3,σ)。精炼计算如下：

```c
for(i=0;i<NumPointsInStrip;i++)//在带区域内的点
    for(j=i+1;j<NumPointsInStrip;j++)
        if(p1 and p2 's coordinates differ by more than 西格玛)//p1 p2两点纵坐标距离大于σ
           break;
        else if(dist(P1,p2)<σ)
           σ=dist(p1,p2);
```

对于任意点Pi，在最坏的情况下最多考虑7个点pj。

### 10.2.3 选择问题

为得到一个好的最坏情形，关键想法是再用一个间接层。我们不 是从随机元素的样本中找出中项，而是从中项的样本中找出中项。基本的枢纽元选择算法如下：

1. 把N个元素分成[N/5]组，5个元素一组，忽略(最多4个)剩余的元素。
2. 找出每组的中项，得到[N/5]个中项的表M。
3. 求出M的中项，将其作为枢纽元p返回。

##### 定理10.9 使用“五分化中项的中项”的快速选择算法的运行时间为O(N)。

### 10.2.4 一些运算问题的理论改进

###### 整数相乘

让我们把 X 和 Y拆成两半，分别由最高几位和最低几位数字组成Xr,Xl,Yr,Yl

则XY相乘表达式为:

- XY = XlYl*10^8 + (XlYr + XrYl)10^4 + XrYr

为了得到一 个亚二次的算法，我们必须使用少于4次的递归调用。关键的观察结果是

-  (XlYr + XrYl)= (Xl —Xr)(Xr—Yl)+XlYl + XrYr

容易看到现在的递归方程满足

- T(N) **=** 3 T (N/2) +O(N)

###### 矩阵乘法

Strassen使用了类似于整数乘法分治 算法的一种策略并指出如何仔细地安排计算而只使用7次递归调用。这7个乘法是：

- M1=(A1,2-A2,2)(B2,1-B2,2)
- M2=(A1,1+A2,2)(B1,1+B2,2)
- M3=(A1,1-A2,1)(B1,1+B1,2)
- M4=(A1,1+A1,2)B2,2
- M5=A1,1(B1,2-B2,2)
- M6=A1,2(B2,2-B1,1)
- M7=(A2,1+A2,2)B1,1

一旦执行这些乘法，则最后答案可以通过下列8次加法得到

- C1,1=M1+M2-M4+M6
- C1,2=M4+M5
- C2,1=M6+M7
- C2,2=M2-M3+M5-M7

直接验证这种机敏的安排得到期望的效果。现在运行时间满足递归关系

- T(N)=7T(N/2)+O(N^2)

## 10.3 动态规划

### 10.3.1 用一个表代替递归

- 用动态规划解决斐波那契数

```c
int Fibonacci( int N )
{
    int i, Last, NextToLast, Answer;
    if( N <= 1 )  return 1;
     Last = NextToLast = 1; 
    for( i = 2; i <= N; i++ )
    {
         Answer = Last + NextToLast; 
         NextToLast = Last;
         Last = Answer;
    }
    return Answer;
}
```

- 用动态规划解决跟踪函数Eval的计算

```c
double Eval( int N )
{
    int i, j;
    double Sum, Answer; 
    double *C;
    C = malloc( sizeof( double ) * ( N + 1 )); 
    if( C == NULL )
        FatalError( "Out of space!!!");
    C[ 0 ] = 1.0; 
    for(i = 1; i<=N;i++)
        {
            Sum = 0.0;
            for( j = 0; j < i;j++)
                Sum += C[j];
            C[ i ] = 2.0 * Sum / i + i; 
        }
    Answer = C[ N ]; 
    free( C );
    return Answer;
}
```

### 10.3.2 矩阵乘法的顺序安排

计算最优乘法次数的主要算法：

- Mleft,right=min{Mleft,i+Mi,right+Cleft-1CiCright}

### 10.3.3 最优二叉查找树

计算最优代价的主要算法是：

- Cleft,right=min{Cleft,i-1+Ci+1,right+∑pi}

具体过程如下：

![image-20211107175450054](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211107175450054.png)

## 10.4 随机化算法

- 在算法期间， 随机数至少有一次用于决策。该算法的运行时间不只依赖于特定的输入，而且依赖于所发 生的随机数。
- 一个随机化算法的最坏情形运行时间几乎总是和非随机化算法的最坏情形运行时间相 同。重要的区别在于，好的随机化算法没有不好的输入，而只有坏的随机数(相对于特定的输入)。

### 10.4.1 随机数发生器

线性同余发生器：

- Xi+1=A*Xi mod M

工作于32位机上的随机数发生器：

```c
static unsigned long Seed = 1;
#define A 48271L
#define M 2147483647L
#define Q ( M / A )
#define R ( M % A )
double Random( void )
{
    long TmpSeed;
    TmpSeed = A * ( Seed % Q ) - R * ( Seed / Q ); 
    if( TmpSeed >= 0 )
        Seed = TmpSeed;
    else
        Seed = TmpSeed + M;
    return ( double ) Seed / M;
}
void Initialize( unsigned long InitVal ) 
{
     Seed = InitVal;
}
```

### 10.4.2 跳跃表

- 为执行一次Find,我们在头节点 从最高阶的指针开始，沿着这个阶一直走，直至找到大于我们正在寻找的节点的下一个节点（或者是NULL）前停下。这个时候，我们转到低一阶的阶并继续这种方法。当进行到一阶停止时，或者我们位于正在寻找的节点的前面，或者它不在这个表中。为了执行一次Insert,我们像在执行Find时那样，始终监视每一个使我们转到下一阶的节点。最后,将新节点（它的阶是随机确定的）拼接到表中。
- 插入前和插入后的跳跃表

![image-20211107180442574](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211107180442574.png)



### 10.4.3素性测试

##### 定理10.10 费马小定理：如果P是素数，且0<A<P,那么A^p-1恒等于1（mod P)。

对于任何 (充分大的)N,至多有A的(N -9)/4个值会使该算法得出错误的结论。因此，如果A是 随机选取的，而且算法的结论是N(很可能)为素数，那么至少有75%的时机算法是正确的。

### 
